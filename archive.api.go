// Code generated by protoc-gen-go_api(github.com/dev-openapi/protoc-gen-go_api version=v1.0.5). DO NOT EDIT.
// source: bilibili-webapp/archive.proto

package bilibili_webapp

import (
	context "context"
	fmt "fmt"
	io "io"
	json "encoding/json"
	bytes "bytes"
	http "net/http"
	strings "strings"
	url "net/url"
	multipart "mime/multipart"
)
// Reference imports to suppress errors if they are not otherwise used.
var _ = context.Background
var _ = http.NewRequest
var _ = io.Copy
var _ = bytes.Compare
var _ = json.Marshal
var _ = strings.Compare
var _ = fmt.Errorf
var _ = url.Parse
var _ = multipart.ErrMessageTooLarge


// Client API for Archive service

type ArchiveService interface {
	// GetArchive  查询单一视频稿件详情 https://openhome.bilibili.com/doc/4/d9554788-dcef-f139-6217-b487d41c3826
	GetArchive(ctx context.Context, in *GetArchiveReq, opts ...Option) (*GetArchiveRes, error)
	// BatchGetArchive  查询用户视频稿件列表 https://openhome.bilibili.com/doc/4/a24030b7-6b8f-b36c-32d8-a4aae67fcc35
	BatchGetArchive(ctx context.Context, in *BatchGetArchiveReq, opts ...Option) (*BatchGetArchiveRes, error)
	// EditArchive  视频稿件编辑 https://openhome.bilibili.com/doc/4/ddfbe54d-b4ab-340e-c698-933b9a3c619c
	EditArchive(ctx context.Context, in *EditArchiveReq, opts ...Option) (*EditArchiveRes, error)
	// DeleteArchive  视频稿件删除 https://openhome.bilibili.com/doc/4/23d78390-4119-1e5f-2bbe-b45bd5cecdb0
	DeleteArchive(ctx context.Context, in *DeleteArchiveReq, opts ...Option) (*DeleteArchiveRes, error)
	// GetArchiveTypeList  获取分区
	GetArchiveTypeList(ctx context.Context, in *GetArchiveTypeListReq, opts ...Option) (*GetArchiveTypeListRes, error)
	// AddArchive  视频稿件提交
	AddArchive(ctx context.Context, in *AddArchiveReq, opts ...Option) (*AddArchiveRes, error)
}

type archiveService struct {
	// opts
	opts *Options
}

func NewArchiveService(opts ...Option) ArchiveService {
	opt := newOptions(opts...)
	if len(opt.addr) <= 0 {
		opt.addr = "https://member.bilibili.com"
	}
	return &archiveService {
		opts: opt,
	}
}


func (c *archiveService) GetArchive(ctx context.Context, in *GetArchiveReq, opts ...Option) (*GetArchiveRes, error) {
	var res GetArchiveRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/archive/view", opt.addr)

	// body
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}
	if in.GetResourceId() != "" {
		params.Add("resource_id", fmt.Sprintf("%v", in.GetResourceId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *archiveService) BatchGetArchive(ctx context.Context, in *BatchGetArchiveReq, opts ...Option) (*BatchGetArchiveRes, error) {
	var res BatchGetArchiveRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/archive/viewlist", opt.addr)

	// body
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}
	if in.GetPn() != 0 {
		params.Add("pn", fmt.Sprintf("%v", in.GetPn()))
	}
	if in.GetPs() != 0 {
		params.Add("ps", fmt.Sprintf("%v", in.GetPs()))
	}
	if in.GetStatus() != "" {
		params.Add("status", fmt.Sprintf("%v", in.GetStatus()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *archiveService) EditArchive(ctx context.Context, in *EditArchiveReq, opts ...Option) (*EditArchiveRes, error) {
	var res EditArchiveRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/archive/edit", opt.addr)

	// body
	bs, err := json.Marshal(in.GetBody())
	if err != nil {
		return nil, err
	}
	body := bytes.NewReader(bs)
	headers["Content-Type"] = "application/json"

	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *archiveService) DeleteArchive(ctx context.Context, in *DeleteArchiveReq, opts ...Option) (*DeleteArchiveRes, error) {
	var res DeleteArchiveRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/archive/delete", opt.addr)

	// body
	bs, err := json.Marshal(in.GetBody())
	if err != nil {
		return nil, err
	}
	body := bytes.NewReader(bs)
	headers["Content-Type"] = "application/json"

	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *archiveService) GetArchiveTypeList(ctx context.Context, in *GetArchiveTypeListReq, opts ...Option) (*GetArchiveTypeListRes, error) {
	var res GetArchiveTypeListRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/archive/type/list", opt.addr)

	// body
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *archiveService) AddArchive(ctx context.Context, in *AddArchiveReq, opts ...Option) (*AddArchiveRes, error) {
	var res AddArchiveRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/archive/add-by-utoken", opt.addr)

	// body
	bs, err := json.Marshal(in.GetBody())
	if err != nil {
		return nil, err
	}
	body := bytes.NewReader(bs)
	headers["Content-Type"] = "application/json"

	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}
	if in.GetUploadToken() != "" {
		params.Add("upload_token", fmt.Sprintf("%v", in.GetUploadToken()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}
