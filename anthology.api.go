// Code generated by protoc-gen-go_api(github.com/dev-openapi/protoc-gen-go_api version=v1.0.5). DO NOT EDIT.
// source: bilibili-webapp/anthology.proto

package bilibili_webapp

import (
	context "context"
	fmt "fmt"
	io "io"
	json "encoding/json"
	bytes "bytes"
	http "net/http"
	strings "strings"
	url "net/url"
	multipart "mime/multipart"
)
// Reference imports to suppress errors if they are not otherwise used.
var _ = context.Background
var _ = http.NewRequest
var _ = io.Copy
var _ = bytes.Compare
var _ = json.Marshal
var _ = strings.Compare
var _ = fmt.Errorf
var _ = url.Parse
var _ = multipart.ErrMessageTooLarge


// Client API for Anthology service

type AnthologyService interface {
	// AddAnthology  文集提交 https://openhome.bilibili.com/doc/4/728b35c7-21f9-d15e-6f0e-5e39c6647903
	AddAnthology(ctx context.Context, in *AddAnthologyReq, opts ...Option) (*AddAnthologyRes, error)
	// EditAnthology  文集信息编辑 https://openhome.bilibili.com/doc/4/0e2f82f8-8b16-2927-0546-ac1a24871501
	EditAnthology(ctx context.Context, in *EditAnthologyReq, opts ...Option) (*EditAnthologyRes, error)
	// EditArticleBelong  文集下文章列表修改 https://openhome.bilibili.com/doc/4/b20487b7-471b-0717-b3b6-e65dd8a5263d
	EditArticleBelong(ctx context.Context, in *EditArticleBelongReq, opts ...Option) (*EditArticleBelongRes, error)
	// DeleteAnthology  文集删除 https://openhome.bilibili.com/doc/4/93289fec-1521-1f3f-c3ec-78108b4c7859
	DeleteAnthology(ctx context.Context, in *DeleteAnthologyReq, opts ...Option) (*DeleteAnthologyRes, error)
	// BatchGetAnthologies  查看文集列表 https://openhome.bilibili.com/doc/4/1caef1c1-0576-91e3-00ed-c287e9866d7e
	BatchGetAnthologies(ctx context.Context, in *BatchGetAnthologiesReq, opts ...Option) (*BatchGetAnthologiesRes, error)
	// GetAnthology  查看文集详情 https://openhome.bilibili.com/doc/4/78228e26-1c25-5b65-e107-a08dabf45850
	GetAnthology(ctx context.Context, in *GetAnthologyReq, opts ...Option) (*GetAnthologyRes, error)
}

type anthologyService struct {
	// opts
	opts *Options
}

func NewAnthologyService(opts ...Option) AnthologyService {
	opt := newOptions(opts...)
	if len(opt.addr) <= 0 {
		opt.addr = "https://member.bilibili.com"
	}
	return &anthologyService {
		opts: opt,
	}
}


func (c *anthologyService) AddAnthology(ctx context.Context, in *AddAnthologyReq, opts ...Option) (*AddAnthologyRes, error) {
	var res AddAnthologyRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/article/anthology/add", opt.addr)

	// body
	bodyForms := url.Values{} 
	if in.GetBody() != nil && in.GetBody().GetImageUrl() != "" {
		bodyForms.Add("image_url", fmt.Sprintf("%v", in.GetBody().GetImageUrl()))
	}
	if in.GetBody() != nil && in.GetBody().GetListId() != 0 {
		bodyForms.Add("list_id", fmt.Sprintf("%v", in.GetBody().GetListId()))
	}
	if in.GetBody() != nil && in.GetBody().GetName() != "" {
		bodyForms.Add("name", fmt.Sprintf("%v", in.GetBody().GetName()))
	}
	if in.GetBody() != nil && in.GetBody().GetSummary() != "" {
		bodyForms.Add("summary", fmt.Sprintf("%v", in.GetBody().GetSummary()))
	}
	body := strings.NewReader(bodyForms.Encode())
	headers["Content-Type"] = "application/x-www-form-urlencoded"

	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *anthologyService) EditAnthology(ctx context.Context, in *EditAnthologyReq, opts ...Option) (*EditAnthologyRes, error) {
	var res EditAnthologyRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/article/anthology/edit", opt.addr)

	// body
	bodyForms := url.Values{} 
	if in.GetBody() != nil && in.GetBody().GetImageUrl() != "" {
		bodyForms.Add("image_url", fmt.Sprintf("%v", in.GetBody().GetImageUrl()))
	}
	if in.GetBody() != nil && in.GetBody().GetListId() != 0 {
		bodyForms.Add("list_id", fmt.Sprintf("%v", in.GetBody().GetListId()))
	}
	if in.GetBody() != nil && in.GetBody().GetName() != "" {
		bodyForms.Add("name", fmt.Sprintf("%v", in.GetBody().GetName()))
	}
	if in.GetBody() != nil && in.GetBody().GetSummary() != "" {
		bodyForms.Add("summary", fmt.Sprintf("%v", in.GetBody().GetSummary()))
	}
	body := strings.NewReader(bodyForms.Encode())
	headers["Content-Type"] = "application/x-www-form-urlencoded"

	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *anthologyService) EditArticleBelong(ctx context.Context, in *EditArticleBelongReq, opts ...Option) (*EditArticleBelongRes, error) {
	var res EditArticleBelongRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/article/belong", opt.addr)

	// body
	bodyForms := url.Values{} 
	if in.GetBody() != nil && in.GetBody().GetArticleIds() != "" {
		bodyForms.Add("article_ids", fmt.Sprintf("%v", in.GetBody().GetArticleIds()))
	}
	if in.GetBody() != nil && in.GetBody().GetListId() != 0 {
		bodyForms.Add("list_id", fmt.Sprintf("%v", in.GetBody().GetListId()))
	}
	body := strings.NewReader(bodyForms.Encode())
	headers["Content-Type"] = "application/x-www-form-urlencoded"

	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *anthologyService) DeleteAnthology(ctx context.Context, in *DeleteAnthologyReq, opts ...Option) (*DeleteAnthologyRes, error) {
	var res DeleteAnthologyRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/article/anthology/delete", opt.addr)

	// body
	bodyForms := url.Values{} 
	if in.GetBody() != nil && in.GetBody().GetId() != 0 {
		bodyForms.Add("id", fmt.Sprintf("%v", in.GetBody().GetId()))
	}
	body := strings.NewReader(bodyForms.Encode())
	headers["Content-Type"] = "application/x-www-form-urlencoded"

	req, err := http.NewRequest("POST", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *anthologyService) BatchGetAnthologies(ctx context.Context, in *BatchGetAnthologiesReq, opts ...Option) (*BatchGetAnthologiesRes, error) {
	var res BatchGetAnthologiesRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/article/anthology/list", opt.addr)

	// body
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}

func (c *anthologyService) GetAnthology(ctx context.Context, in *GetAnthologyReq, opts ...Option) (*GetAnthologyRes, error) {
	var res GetAnthologyRes
	// options
	opt := buildOptions(c.opts, opts...)
	headers := make(map[string]string)
	// route
	rawURL := fmt.Sprintf("%s/arcopen/fn/article/anthology/detail", opt.addr)

	// body
	bodyForms := url.Values{} 
	if in.GetBody() != nil && in.GetBody().GetId() != 0 {
		bodyForms.Add("id", fmt.Sprintf("%v", in.GetBody().GetId()))
	}
	body := strings.NewReader(bodyForms.Encode())
	headers["Content-Type"] = "application/x-www-form-urlencoded"

	req, err := http.NewRequest("GET", rawURL, body)
	if err != nil {
		return nil, err
	}
	
	params := req.URL.Query()
	if in.GetAccessToken() != "" {
		params.Add("access_token", fmt.Sprintf("%v", in.GetAccessToken()))
	}
	if in.GetClientId() != "" {
		params.Add("client_id", fmt.Sprintf("%v", in.GetClientId()))
	}	
	req.URL.RawQuery = params.Encode()
	
	// header
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	resp, err := opt.DoRequest(ctx, opt.client, req)
	if err != nil {
		return nil, err
	}
	err = opt.DoResponse(ctx, resp, &res)
	return &res, err 

}
